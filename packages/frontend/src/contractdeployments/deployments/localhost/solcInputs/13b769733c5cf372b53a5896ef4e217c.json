{
  "language": "Solidity",
  "sources": {
    "contracts/MetaCoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.7.6;\n\nimport \"@opengsn/contracts/src/BaseRelayRecipient.sol\";\n\ncontract MetaCoin is BaseRelayRecipient {\n\n\tstring public symbol = \"META\";\n\tstring public description = \"GSN Sample MetaCoin\";\n\tuint public decimals = 0;\n\n\tmapping(address => uint) balances;\n\n\tconstructor(address forwarder) public {\n        balances[tx.origin] = 10000;\n        trustedForwarder = forwarder;\n    }\n\n    function versionRecipient() external override view returns (string memory) {\n        return \"2.0.0\";\n    }\n\n    function transfer(address receiver, uint amount) public returns (bool sufficient) {\n        if (balances[_msgSender()] < amount) return false;\n        balances[_msgSender()] -= amount;\n        balances[receiver] += amount;\n        // emit Transfer(_msgSender(), receiver, amount);\n        return true;\n    }\n\n    function balanceOf(address addr) public view returns (uint) {\n        return balances[addr];\n    }\n\n\n    mapping(address => bool) minted;\n\n    /**\n     * mint some coins for this caller.\n     * (in a real-life application, minting is protected for admin, or by other mechanism.\n     * but for our sample, any user can mint some coins - but just once..\n     */\n    function mint(uint amount) public {\n        require(!minted[_msgSender()], \"already minted\");\n        minted[_msgSender()] = true;\n        balances[_msgSender()] += amount;\n    }\n}\n"
    },
    "@opengsn/contracts/src/BaseRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\n// solhint-disable no-inline-assembly\npragma solidity >=0.7.6;\n\nimport \"./interfaces/IRelayRecipient.sol\";\n\n/**\n * A base contract to be inherited by any contract that want to receive relayed transactions\n * A subclass must use \"_msgSender()\" instead of \"msg.sender\"\n */\nabstract contract BaseRelayRecipient is IRelayRecipient {\n\n    /*\n     * Forwarder singleton we accept calls from\n     */\n    address public trustedForwarder;\n\n    function isTrustedForwarder(address forwarder) public override view returns(bool) {\n        return forwarder == trustedForwarder;\n    }\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, return the original sender.\n     * otherwise, return `msg.sender`.\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal override virtual view returns (address payable ret) {\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\n            // At this point we know that the sender is a trusted forwarder,\n            // so we trust that the last bytes of msg.data are the verified sender address.\n            // extract sender address from the end of msg.data\n            assembly {\n                ret := shr(96,calldataload(sub(calldatasize(),20)))\n            }\n        } else {\n            return msg.sender;\n        }\n    }\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise, return `msg.data`\n     * should be used in the contract instead of msg.data, where the difference matters (e.g. when explicitly\n     * signing or hashing the\n     */\n    function _msgData() internal override virtual view returns (bytes memory ret) {\n        if (msg.data.length >= 20 && isTrustedForwarder(msg.sender)) {\n            return msg.data[0:msg.data.length-20];\n        } else {\n            return msg.data;\n        }\n    }\n}\n"
    },
    "@opengsn/contracts/src/interfaces/IRelayRecipient.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-only\npragma solidity >=0.7.6;\n\n/**\n * a contract must implement this interface in order to support relayed transaction.\n * It is better to inherit the BaseRelayRecipient as its implementation.\n */\nabstract contract IRelayRecipient {\n\n    /**\n     * return if the forwarder is trusted to forward relayed transactions to us.\n     * the forwarder is required to verify the sender's signature, and verify\n     * the call is not a replay.\n     */\n    function isTrustedForwarder(address forwarder) public virtual view returns(bool);\n\n    /**\n     * return the sender of this call.\n     * if the call came through our trusted forwarder, then the real sender is appended as the last 20 bytes\n     * of the msg.data.\n     * otherwise, return `msg.sender`\n     * should be used in the contract anywhere instead of msg.sender\n     */\n    function _msgSender() internal virtual view returns (address payable);\n\n    /**\n     * return the msg.data of this call.\n     * if the call came through our trusted forwarder, then the real sender was appended as the last 20 bytes\n     * of the msg.data - so this method will strip those 20 bytes off.\n     * otherwise (if the call was made directly and not through the forwarder), return `msg.data`\n     * should be used in the contract instead of msg.data, where this difference matters.\n     */\n    function _msgData() internal virtual view returns (bytes memory);\n\n    function versionRecipient() external virtual view returns (string memory);\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}